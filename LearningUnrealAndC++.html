<!DOCTYPE HTML>
<!--
	Dopetrope by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Learning Unreal and C++</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="no-sidebar is-preload">
		<div id="page-wrapper">

			<!-- Header -->
				<section id="header">

					<!-- Logo -->
						<h1><a href="LearningUnrealAndC++.html">Learning Unreal Engine and C++</a></h1>

					<!-- Nav -->
				<nav id="nav">
					<ul>
						<li><a href="index.html">Home</a></li>
						<li class="current">
							<a href="#">Projects</a>
							<ul>
								<li ><a href="Freeflight.html">Freeflight</a></li>
								<li><a href="BoidsSimulatedEcosystem.html">Boids Simulated Ecosystem</a></li>
								<li><a href="ProjectStealth.html">Project Stealth</a></li>
								<li><a href="CustomController.html">Custom Controller Fishing Game</a></li>
								<li><a href="LearningUnrealAndC++.html">Learning Unreal Engine and C++</a></li>
								<!-- 
								<li><a href="PracticeProjects">Practice Projects</a>
									<ul>
										<li><a href="#">Procedural Generation</a></li>
										<li><a href="#">Building Ghost + Placement</a></li>
										<li><a href="#">Path Creator</a></li>
										<li><a href="#">Resource System</a></li>
										<li><a href="#">Learning Shaders</a></li>
									</ul>
								</li>
								-->
							</ul>
						</li>
						<li><a href="EducationAndAccomplishments.html">Education and Accomplishments</a></li>
						<!--<li><a href="HobbiesAndInterests.html">Hobbies and Interests</a></li>-->
						<li><a href="CV.html">CV</a></li>
					</ul>
				</nav>

				</section>

			<!-- Main -->
				<section id="main">
					<div class="container">

						<!-- Content -->
							<article class="box post">
								<a target="_blank" href="" class="image featured"><img src="" alt="" /></a>
								<header>
									<h2>Overview</h2>
								</header>
								<p>
									I have been developing my skills in using Unreal Engine and C++. To accomplish this, I have been following a Udemy course to aid in my learning (This course can be found
									<a target="_blank" href=https://www.udemy.com/course/unrealcourse /> here</a>). For these projects, I used Unreal Engine Version 5.1.
								</p>
								<p>
									Within this course, I have created 3 different game demos. These being Warehouse Wreckage, Obstacle Assult, and Crypt Raider, with the complexity of these projects
									increasing after each. These games focus on developing my understanding of different aspects of working in Unreal Engine and C++. After developing each of these games,
									I then proceeded to test my knowledge by adding my own mechanic to each game, whilst also improving the tutorial code where possible. I did this so that I could develop 
									better knowledge of using C++, resulting in me having a much greater understanding of how to use it. 
								</p>
								<header>
									<h2>
										The projects I have made:
									</h2>
									
								</header>

										<button type="button" class="collapsible">Warehouse Wreckage</button>
										<div class="content">
											<section>
												<p>
													<br />
													Warehouse Wreckage is a first-person destruction game where the player can run around shooting different environmental items to knock them over.
													Some examples of these items are cones, barrels, shelves, and more. The player then has access to restart the level as many times as they want.
													I created this game with a focus on learning Unreal Engine's basic features, including getting a good understanding of how to use blueprints to
													perform simple tasks.
												</p>
												<h4>What I focused on whilst making this:</h4>
												<p>
													During this project I focused on improving my basic in-engine skills. This included how to properly make use of the viewport, moving/placing actors,
													BSP, basic Blueprint usage, and more. Within this game, I used Blueprints to spawn in objects, shoot out projectiles, and manage the scene. This project
													used the default Unreal Engine player controller.
												</p>
												<!--
													-> Learning basic Unreal usage
													-> Navigating viewport
													-> Moving/placing actors
													-> using unreal tools for level building
														-> bsp

													-> Learning through blueprints
														-> spawn in projects
														-> aiming projectiles
														-> reload levels
												-->
												<h4>Example Systems + Scripts</h4>

												<br />

												<button type="button" class="collapsible">Level Screenshots</button>
												<div class="content">
													<br />
													<img src="images/WarehouseWreckage/CornerScreenshot.PNG" alt="" />
													<img src="images/WarehouseWreckage/Screenshot2.PNG" alt="" />
													<img src="images/WarehouseWreckage/Screenshot3.PNG" alt="" />
												</div>
												<br />
												<br />

												<button type="button" class="collapsible">Blueprints</button>
												<div class="content">
													<br />
													<p>
														
													</p>
													<h4>Level Blueprint</h4>
													<img src="images/WarehouseWreckage/LevelBlueprint.PNG" alt="" />
													<p>
														Above is the main level Blueprint responsible for spawning in a projectile and firing it in a forward direction.
														<br />
														<br />
														The top section takes any input from the backspace key and calls the ReloadLevel function when this key is pressed. This function gets the
														current level name and then passes this into an "OpenLevel(by name)" node, resulting in the level reloading.
														<br />
														<br />
														The bottom section is responsible for spawning a projectile when the spacebar key in pressed. This blueprint uses a branch so that when the 
														space bar key is pressed, it checks if it has ammo and either spawns in a new projectile or reloads the gun, calling the relevant functions 
														to do so.
													</p>

													<h4>Spawn Projectile Function</h4>
													<img src="images/WarehouseWreckage/Level_SpawnProjectile.PNG" alt="" />
													<p>
														The Spawn Projectile function is responsible for spawning in a new projectile into the level and ensuring an impulse is applied upon this 
														creation. When called, this function spawns in a new projectile, ensuring the rotation and position is taken from the player pawn, and then 
														calls the add impulse function, passing this new projectile as a target reference.
													</p>

													<h4>Add Impulse Function</h4>
													<img src="images/WarehouseWreckage/AddImpulse.PNG" alt="" />
													<p>
														When called, this function gets an actor and applies an impulse force in the forward direction with a given amount of force.
													</p>


													<h4>Decrease Ammo Function</h4>
													<img src="images/WarehouseWreckage/Level_DecreaseAmmo.PNG" alt="" />
													<p>
														When called, this function lowers the ammo count by one
													</p>

													

												</div>

											<section>
												<header>
													<h4>Overview:</h4>
												</header>
												<p>
													Completing this blueprint system and combining it with Unreal Engine's other built-in features have been able to give me a great understanding of
													the basic functionaility of this engine and how to make good use of it.
												</p>
											</section>

										</div>
										<br />
										<br />
										<button type="button" class="collapsible">Obstacle Assault</button>
										<div class="content">
											<section>
												<br />
												<p>
													Obstacle Assault is a third-person parkour game where the player has to use their environment in order to progress on throughout the level.
													Some different environmental features includes moving platforms, rotating platforms, and jumping puzzles. I created this game with a focus 
													on learning basic C++ usage for scripts in Unreal Engine, and how I can use these scripts to manipulate the environment during play time.
												</p>
												<h4>What I focused on whilst making this:</h4>
												<p>
													During this project, I focused on learning basic C++ usage in Unreal. This included learning how to manipulate an actor's movement and rotation
													during run time. The script I made was a configurable C++ script that allowed the user to make an actor move to and from a given distance and
													direction, whilst also allowing them to configure it to have a rotation. I also looked into creating C++ actors, Unreal Engine's live coding 
													feature, and linking blueprint to C++.
												</p>
												<!--
													-> Learning basic C++ in Unreal
														-> Make platforms move
															-> configurable speed
															-> Backward and forward
														-> Rotation
															-> Rotating platforms

													-> Creating a C++ Actor
													-> C++ compilation and live coding
													-> Linking blueprint to C++
													-> Setting own custom character class

													Things I did myself:
														-> Noticed you could crouch in the air
															-> fixed through creating branch checking whether grounded or not
														-> Added option for platform to move between multiple locations

												-->
												<header>
													<h4>Example Systems + Scripts</h4>
												</header>

												<button type="button" class="collapsible">Level Screenshots</button>
												<div class="content">
													<br />
													<img src="images/ObstacleAssault/spinners.PNG" alt="" />
													<p>Above is an image of spinner object. I made these yellow discs rotate clockwise to make it more difficult for the player to naviagte the terrain</p>

													<img src="images/ObstacleAssault/Screenshot2.PNG" alt="" />
													<p>Above is an image containing two types of moving blocks. The stone block on the right moves up and down to allow the player access to higher ground,
													meanwhile the purple cubes move side to side to provide an obstacle to the player as they move on within the level.</p>
												</div>
												<br />
												<br />

												<button type="button" class="collapsible">C++ Script Screenshots</button>
												<div class="content">
													<br />
													<h4>MovingPlatform.h</h4>
													<img src="images/ObstacleAssault/MovingPlatformH.PNG" alt="" />
													<p>
														Above is the header file for the MovingPlatform script. I ensured to categorize and allow the main variables to be edited within the editor so that
														the settings can be customized for different objects.
													</p>
													<h4>MovingPlatform.cpp</h4>
													<img src="images/ObstacleAssault/MovingPlatformCPP.PNG" alt="" />
													<p>
														Above is the main C++ script that handles moving and rotating an actor. Every tick this script calls 2 functions: MovePlatform() and RotatePlatform(),
														passing DeltaTime into these so it can be used for calculations.
														<br />
														<br />
														The MovePlatform() function applies a movement to the actor in a preset direction and speed. It functions through checking if the actor has reached
														it's destination, in which if it has, it will reset it's start location and send the actor back in the direction it came from. However, If the actor 
														hasn't reached it's destination, the actor will be moved towards it's destination.
														<br />
														<br />
														The RotatePlatform() function applies a local rotation to the actor by a preset rotationSpeed value.
													</p>

												</div>
											</section>
											<section>
												<header>
													<h4>Overview:</h4>
												</header>
												<p>
													Completing this C++ system and implementing it into Unreal Engine has helped me develop an understanding of how C++ scripts function, and how I
													can use them to manipulate actors throughout the scene. From doing this project, I have learnt how to create, add functionality to, and set up 
													c++ scripts so they can function within an Unreal Engine project. 
													<br />
													<br />
													I plan to come back to this project in the future to add greater functionality and ideas I have to make the gameplay much more enjoyable and to
													add more depth to the gameplay loop.
												</p>
											</section>
										</div>
										<br />
										<br />
										<button type="button" class="collapsible">Crypt Raider</button>
										<div class="content">
											<section>
												<br />
												<p>
													Crypt Raider is a first-person puzzle game where the player can run around and interact with different objects throughout the environment to
													help them progress through the level and get to the end. I created this game with a focus on obtaining a greater understanding of C++ and 
													how I can use this language to create some more advanced behaviours for my game. I also took my time whislt working on this project to look 
													into Unreal Engine's lighting system, including UE5's new Lumen lighting system.
												</p>
												<h4>What I focused on whilst making this:</h4>
												<p>
													During this project, I focused on better understanding C++. This included things such as pointers and references, actor and scene components,
													header files, and more. In this project I make a few different C++ scripts, including a script to allow the player to pick up objects in the 
													environment, a script that allowed an object to move a given distance in a given direction when set to move, and a custom trigger component 
													that worked with the mover script to allow for me to implement puzzles into the map.
												</p>
												<!--
														-> Pointers and references
														-> Actor Components and Scene Components
															-> Inc header files
														-> Lighting with Lumen
														-> Modular level design		-> Write why I learnt this	-> better understanding of the inner-workings of Unreal? Better understanding of design-perspective?
														-> Line tracing and collisions
														-> While, for loops, and arrays
														-> Calling C++ functions from Blueprint
												-->
												<header>
													<h4>Example Systems + Scripts</h4>
												</header>

												<button type="button" class="collapsible">Level Screenshots</button>
												<div class="content">
													<br />
													<img src="images/CryptRaider/Screenshot1.PNG" alt="" />
													<img src="images/CryptRaider/Screenshot2.PNG" alt="" />
													<img src="images/CryptRaider/before.PNG" alt="" />
													<p>The above picture is before I put the gargoyle key on the podium, meaning the hidden wall was still up</p>
													<img src="images/CryptRaider/after.PNG" alt="" />
													<p>This picture shows the gargoyle on the podium, meaning the hidden wall has been lowered due to the key being in place</p>

												</div>
												<br />
												<br />
												<button type="button" class="collapsible">C++ and Blueprints</button>
												<div class="content">
													<br />
													<h4>Grabber.cpp</h4>
													<p>
														The two images below make up the Grabber component. This script is responsible for enabling the player to pickup and drop objects around
														the map.
													</p>
													<img src="images/CryptRaider/grabberCPP1.PNG" alt="" />
													<p>
														As seen above, every tick we check if we have an object held within the physics handle and ensure we hold the object infront of the player.
														<br />
														<br />
														Above is also the Release Function. This function is responsible for releasing any held object so that the player can drop a held object 
														in a place they want. Firstly, I get a reference to the physics handle to get the grabbed component so I can reset it and remove the "Grabbed"
														tag. I then call the ReleaseComponent() function within the physics handle. After this, the object will be in world space, letting the player 
														leave it where they choose.
													</p>
													<img src="images/CryptRaider/grabberCPP2.PNG" alt="" />

													<p>
														Above is the Grab, PickupItemInReach, and GetPhysicsHandle functions. The Grab function is responsible for picking up an object and setting it
														up for being carried. Firstly, I get a reference to the physics handle so I can reference this later, and create a FHitResult variable to hold
														objects the player is looking at within the scene. I then check if there is an item within reach through calling the PickupItemInReach function.
														If an item is found, I get this hit object's primitive component and set it up for being carried by the player, ensuring to give it the "Grabbed"
														tag and detatching it from it's parent object if it has one. I then call the GrabComponentAtLocationWithRotation from the physics handle, passing
														this hitComponent.
														<br />
														<br />
														The PickupItemInReach is a function that sends out a sweep and returns a boolean value depending on whether an object that can be picked up has
														been found, using a sphere as it's collision shape. Finally, the GetPhysicsHandle function simply returns the object's physics handle component.
													</p>

													<h4>Mover.cpp</h4>
													<img src="images/CryptRaider/moverCPP.PNG" alt="" />
													<p>
														The script above is the script responsible for moving an object in a given direction and speed, provided it has been set to be able to move. The 
														script functions through the main TickComponent function. It works through assigning a target location and then applying a move to this location
														if the component is set to move. After this, I then get the movement through using VInterConstantTo from FMath, passing in a calculated speed,
														the object's current location, and the target location. Finally, I pass this calculated movement into the SetActorLocation function of the owner
														object.
													</p>
													<p>
														I also make use of a public SetShouldMove function, so that other components can set this value easily.
													</p>

													<h4>TriggerComponent.cpp</h4>
													<img src="images/CryptRaider/TriggerComponentCPP.PNG" alt="" />
													<p>
														The script above is the TriggerComponent script. This is a custom trigger object that activates a mover, provided a given key is present within
														the trigger area.
														<br />
														<br />
														This script functions through calling the FindAcceptableKey each tick. This function is responsible for setting the canMove value in a preset 
														Mover to either true or false, depending on whether the correct key is present. Firstly, the GetAcceptableActor function is called to obtain
														an actor with the correct tag, in which if one isn't found, the mover is set to not move. Alternatively, if an actor is found with the correct
														key as it's tag, the object is set up to remain in the location it was dropped and is parented to this object. Then, finally, the Mover object's
														canMove bool is set to true, since the correct key has been placed into the trigger area.
														<br />
														<br />
														The GetAcceptableActor function returns an actor within the trigger area, provided it has the correct tag. Firstly, I create a TArray of actors
														and pass this into the GetOverlappingActors function, then I filter through each actor found and check whether it has the correct key tag, in 
														which if it does I return this actor to where it was called. If no actor is found with the given key, a nullptr is returned.
													</p>

												</div>
												<br />
												<br />
											</section>
											<section>
												<header>
													<h4>Overview:</h4>
												</header>
												<p>

												</p>
											</section>
										</div>
										<br />
										<br />
								<!--
								<button type="button" class="collapsible">Extra</button>
								<div class="content">
									<p>
										Talk about next project -> FPS Time trial puzzle game
									</p>

								</div>
									-->
							</article>

					</div>
				</section>
		</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>